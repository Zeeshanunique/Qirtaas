"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/long";
exports.ids = ["vendor-chunks/long"];
exports.modules = {

/***/ "(ssr)/./node_modules/long/umd/index.js":
/*!****************************************!*\
  !*** ./node_modules/long/umd/index.js ***!
  \****************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// GENERATED FILE. DO NOT EDIT.\n\nvar Long = function(exports1) {\n    \"use strict\";\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.default = void 0;\n    /**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   */ // WebAssembly optimizations to do native i64 multiplication and divide\n    var wasm = null;\n    try {\n        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n            // \\0asm\n            0,\n            97,\n            115,\n            109,\n            // version 1\n            1,\n            0,\n            0,\n            0,\n            // section \"type\"\n            1,\n            13,\n            2,\n            // 0, () => i32\n            96,\n            0,\n            1,\n            127,\n            // 1, (i32, i32, i32, i32) => i32\n            96,\n            4,\n            127,\n            127,\n            127,\n            127,\n            1,\n            127,\n            // section \"function\"\n            3,\n            7,\n            6,\n            // 0, type 0\n            0,\n            // 1, type 1\n            1,\n            // 2, type 1\n            1,\n            // 3, type 1\n            1,\n            // 4, type 1\n            1,\n            // 5, type 1\n            1,\n            // section \"global\"\n            6,\n            6,\n            1,\n            // 0, \"high\", mutable i32\n            127,\n            1,\n            65,\n            0,\n            11,\n            // section \"export\"\n            7,\n            50,\n            6,\n            // 0, \"mul\"\n            3,\n            109,\n            117,\n            108,\n            0,\n            1,\n            // 1, \"div_s\"\n            5,\n            100,\n            105,\n            118,\n            95,\n            115,\n            0,\n            2,\n            // 2, \"div_u\"\n            5,\n            100,\n            105,\n            118,\n            95,\n            117,\n            0,\n            3,\n            // 3, \"rem_s\"\n            5,\n            114,\n            101,\n            109,\n            95,\n            115,\n            0,\n            4,\n            // 4, \"rem_u\"\n            5,\n            114,\n            101,\n            109,\n            95,\n            117,\n            0,\n            5,\n            // 5, \"get_high\"\n            8,\n            103,\n            101,\n            116,\n            95,\n            104,\n            105,\n            103,\n            104,\n            0,\n            0,\n            // section \"code\"\n            10,\n            191,\n            1,\n            6,\n            // 0, \"get_high\"\n            4,\n            0,\n            35,\n            0,\n            11,\n            // 1, \"mul\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            126,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 2, \"div_s\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            127,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 3, \"div_u\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            128,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 4, \"rem_s\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            129,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 5, \"rem_u\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            130,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11\n        ])), {}).exports;\n    } catch  {\n    // no wasm support :(\n    }\n    /**\n   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n   *  See the from* functions below for more convenient ways of constructing Longs.\n   * @exports Long\n   * @class A Long class for representing a 64 bit two's-complement integer value.\n   * @param {number} low The low (signed) 32 bits of the long\n   * @param {number} high The high (signed) 32 bits of the long\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @constructor\n   */ function Long(low, high, unsigned) {\n        /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */ this.low = low | 0;\n        /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */ this.high = high | 0;\n        /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */ this.unsigned = !!unsigned;\n    }\n    // The internal representation of a long is the two given signed, 32-bit values.\n    // We use 32-bit pieces because these are the size of integers on which\n    // Javascript performs bit-operations.  For operations like addition and\n    // multiplication, we split each number into 16 bit pieces, which can easily be\n    // multiplied within Javascript's floating-point representation without overflow\n    // or change in sign.\n    //\n    // In the algorithms below, we frequently reduce the negative case to the\n    // positive case by negating the input(s) and then post-processing the result.\n    // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n    // a positive number, it overflows back into a negative).  Not handling this\n    // case would often result in infinite recursion.\n    //\n    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n    // methods on which they depend.\n    /**\n   * An indicator used to reliably determine if an object is a Long or not.\n   * @type {boolean}\n   * @const\n   * @private\n   */ Long.prototype.__isLong__;\n    Object.defineProperty(Long.prototype, \"__isLong__\", {\n        value: true\n    });\n    /**\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   * @inner\n   */ function isLong(obj) {\n        return (obj && obj[\"__isLong__\"]) === true;\n    }\n    /**\n   * @function\n   * @param {*} value number\n   * @returns {number}\n   * @inner\n   */ function ctz32(value) {\n        var c = Math.clz32(value & -value);\n        return value ? 31 - c : c;\n    }\n    /**\n   * Tests if the specified object is a Long.\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   */ Long.isLong = isLong;\n    /**\n   * A cache of the Long representations of small integer values.\n   * @type {!Object}\n   * @inner\n   */ var INT_CACHE = {};\n    /**\n   * A cache of the Long representations of small unsigned integer values.\n   * @type {!Object}\n   * @inner\n   */ var UINT_CACHE = {};\n    /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromInt(value, unsigned) {\n        var obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if (cache = 0 <= value && value < 256) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = fromBits(value, 0, true);\n            if (cache) UINT_CACHE[value] = obj;\n            return obj;\n        } else {\n            value |= 0;\n            if (cache = -128 <= value && value < 128) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache) INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    /**\n   * Returns a Long representing the given 32 bit integer value.\n   * @function\n   * @param {number} value The 32 bit integer in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromInt = fromInt;\n    /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromNumber(value, unsigned) {\n        if (isNaN(value)) return unsigned ? UZERO : ZERO;\n        if (unsigned) {\n            if (value < 0) return UZERO;\n            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n        } else {\n            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n        }\n        if (value < 0) return fromNumber(-value, unsigned).neg();\n        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    /**\n   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n   * @function\n   * @param {number} value The number in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromNumber = fromNumber;\n    /**\n   * @param {number} lowBits\n   * @param {number} highBits\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    /**\n   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n   *  assumed to use 32 bits.\n   * @function\n   * @param {number} lowBits The low 32 bits\n   * @param {number} highBits The high 32 bits\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromBits = fromBits;\n    /**\n   * @function\n   * @param {number} base\n   * @param {number} exponent\n   * @returns {number}\n   * @inner\n   */ var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n    /**\n   * @param {string} str\n   * @param {(boolean|number)=} unsigned\n   * @param {number=} radix\n   * @returns {!Long}\n   * @inner\n   */ function fromString(str, unsigned, radix) {\n        if (str.length === 0) throw Error(\"empty string\");\n        if (typeof unsigned === \"number\") {\n            // For goog.math.long compatibility\n            radix = unsigned;\n            unsigned = false;\n        } else {\n            unsigned = !!unsigned;\n        }\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return unsigned ? UZERO : ZERO;\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n        var p;\n        if ((p = str.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n        else if (p === 0) {\n            return fromString(str.substring(1), unsigned, radix).neg();\n        }\n        // Do several (8) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = fromNumber(pow_dbl(radix, 8));\n        var result = ZERO;\n        for(var i = 0; i < str.length; i += 8){\n            var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                var power = fromNumber(pow_dbl(radix, size));\n                result = result.mul(power).add(fromNumber(value));\n            } else {\n                result = result.mul(radixToPower);\n                result = result.add(fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    /**\n   * Returns a Long representation of the given string, written using the specified radix.\n   * @function\n   * @param {string} str The textual representation of the Long\n   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromString = fromString;\n    /**\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromValue(val, unsigned) {\n        if (typeof val === \"number\") return fromNumber(val, unsigned);\n        if (typeof val === \"string\") return fromString(val, unsigned);\n        // Throws for non-objects, converts non-instanceof Long:\n        return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    /**\n   * Converts the specified value to a Long using the appropriate from* function for its type.\n   * @function\n   * @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long}\n   */ Long.fromValue = fromValue;\n    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n    // no runtime penalty for these.\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_16_DBL = 1 << 16;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_24_DBL = 1 << 24;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n    /**\n   * @type {!Long}\n   * @const\n   * @inner\n   */ var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n    /**\n   * @type {!Long}\n   * @inner\n   */ var ZERO = fromInt(0);\n    /**\n   * Signed zero.\n   * @type {!Long}\n   */ Long.ZERO = ZERO;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var UZERO = fromInt(0, true);\n    /**\n   * Unsigned zero.\n   * @type {!Long}\n   */ Long.UZERO = UZERO;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var ONE = fromInt(1);\n    /**\n   * Signed one.\n   * @type {!Long}\n   */ Long.ONE = ONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var UONE = fromInt(1, true);\n    /**\n   * Unsigned one.\n   * @type {!Long}\n   */ Long.UONE = UONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var NEG_ONE = fromInt(-1);\n    /**\n   * Signed negative one.\n   * @type {!Long}\n   */ Long.NEG_ONE = NEG_ONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n    /**\n   * Maximum signed value.\n   * @type {!Long}\n   */ Long.MAX_VALUE = MAX_VALUE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n    /**\n   * Maximum unsigned value.\n   * @type {!Long}\n   */ Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n    /**\n   * Minimum signed value.\n   * @type {!Long}\n   */ Long.MIN_VALUE = MIN_VALUE;\n    /**\n   * @alias Long.prototype\n   * @inner\n   */ var LongPrototype = Long.prototype;\n    /**\n   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.toInt = function toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    /**\n   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.toNumber = function toNumber() {\n        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    };\n    /**\n   * Converts the Long to a string written in the specified radix.\n   * @this {!Long}\n   * @param {number=} radix Radix (2-36), defaults to 10\n   * @returns {string}\n   * @override\n   * @throws {RangeError} If `radix` is out of range\n   */ LongPrototype.toString = function toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n        if (this.isZero()) return \"0\";\n        if (this.isNegative()) {\n            // Unsigned Longs are never negative\n            if (this.eq(MIN_VALUE)) {\n                // We need to change the Long value before it can be negated, so we remove\n                // the bottom-most digit in this base and then recurse to do the rest.\n                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            } else return \"-\" + this.neg().toString(radix);\n        }\n        // Do several (6) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n        var result = \"\";\n        while(true){\n            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) return digits + result;\n            else {\n                while(digits.length < 6)digits = \"0\" + digits;\n                result = \"\" + digits + result;\n            }\n        }\n    };\n    /**\n   * Gets the high 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed high bits\n   */ LongPrototype.getHighBits = function getHighBits() {\n        return this.high;\n    };\n    /**\n   * Gets the high 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned high bits\n   */ LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n        return this.high >>> 0;\n    };\n    /**\n   * Gets the low 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed low bits\n   */ LongPrototype.getLowBits = function getLowBits() {\n        return this.low;\n    };\n    /**\n   * Gets the low 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned low bits\n   */ LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n        return this.low >>> 0;\n    };\n    /**\n   * Gets the number of bits needed to represent the absolute value of this Long.\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n        if (this.isNegative()) // Unsigned Longs are never negative\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        var val = this.high != 0 ? this.high : this.low;\n        for(var bit = 31; bit > 0; bit--)if ((val & 1 << bit) != 0) break;\n        return this.high != 0 ? bit + 33 : bit + 1;\n    };\n    /**\n   * Tests if this Long can be safely represented as a JavaScript number.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isSafeInteger = function isSafeInteger() {\n        // 2^53-1 is the maximum safe value\n        var top11Bits = this.high >> 21;\n        // [0, 2^53-1]\n        if (!top11Bits) return true;\n        // > 2^53-1\n        if (this.unsigned) return false;\n        // [-2^53, -1] except -2^53\n        return top11Bits === -1 && !(this.low === 0 && this.high === -0x200000);\n    };\n    /**\n   * Tests if this Long's value equals zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isZero = function isZero() {\n        return this.high === 0 && this.low === 0;\n    };\n    /**\n   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n   * @returns {boolean}\n   */ LongPrototype.eqz = LongPrototype.isZero;\n    /**\n   * Tests if this Long's value is negative.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isNegative = function isNegative() {\n        return !this.unsigned && this.high < 0;\n    };\n    /**\n   * Tests if this Long's value is positive or zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isPositive = function isPositive() {\n        return this.unsigned || this.high >= 0;\n    };\n    /**\n   * Tests if this Long's value is odd.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isOdd = function isOdd() {\n        return (this.low & 1) === 1;\n    };\n    /**\n   * Tests if this Long's value is even.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isEven = function isEven() {\n        return (this.low & 1) === 0;\n    };\n    /**\n   * Tests if this Long's value equals the specified's.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.equals = function equals(other) {\n        if (!isLong(other)) other = fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n        return this.high === other.high && this.low === other.low;\n    };\n    /**\n   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n   * @function\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.eq = LongPrototype.equals;\n    /**\n   * Tests if this Long's value differs from the specified's.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.notEquals = function notEquals(other) {\n        return !this.eq(/* validates */ other);\n    };\n    /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.neq = LongPrototype.notEquals;\n    /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.ne = LongPrototype.notEquals;\n    /**\n   * Tests if this Long's value is less than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lessThan = function lessThan(other) {\n        return this.comp(/* validates */ other) < 0;\n    };\n    /**\n   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n   * @function\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lt = LongPrototype.lessThan;\n    /**\n   * Tests if this Long's value is less than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n        return this.comp(/* validates */ other) <= 0;\n    };\n    /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lte = LongPrototype.lessThanOrEqual;\n    /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.le = LongPrototype.lessThanOrEqual;\n    /**\n   * Tests if this Long's value is greater than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.greaterThan = function greaterThan(other) {\n        return this.comp(/* validates */ other) > 0;\n    };\n    /**\n   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n   * @function\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.gt = LongPrototype.greaterThan;\n    /**\n   * Tests if this Long's value is greater than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n        return this.comp(/* validates */ other) >= 0;\n    };\n    /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n    /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n    /**\n   * Compares this Long's value with the specified's.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */ LongPrototype.compare = function compare(other) {\n        if (!isLong(other)) other = fromValue(other);\n        if (this.eq(other)) return 0;\n        var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg) return -1;\n        if (!thisNeg && otherNeg) return 1;\n        // At this point the sign bits are the same\n        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n        // Both are positive if at least one is unsigned\n        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    };\n    /**\n   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n   * @function\n   * @param {!Long|number|bigint|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */ LongPrototype.comp = LongPrototype.compare;\n    /**\n   * Negates this Long's value.\n   * @this {!Long}\n   * @returns {!Long} Negated Long\n   */ LongPrototype.negate = function negate() {\n        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n        return this.not().add(ONE);\n    };\n    /**\n   * Negates this Long's value. This is an alias of {@link Long#negate}.\n   * @function\n   * @returns {!Long} Negated Long\n   */ LongPrototype.neg = LongPrototype.negate;\n    /**\n   * Returns the sum of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} addend Addend\n   * @returns {!Long} Sum\n   */ LongPrototype.add = function add(addend) {\n        if (!isLong(addend)) addend = fromValue(addend);\n        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xFFFF;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xFFFF;\n        var b48 = addend.high >>> 16;\n        var b32 = addend.high & 0xFFFF;\n        var b16 = addend.low >>> 16;\n        var b00 = addend.low & 0xFFFF;\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xFFFF;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c48 += a48 + b48;\n        c48 &= 0xFFFF;\n        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    /**\n   * Returns the difference of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */ LongPrototype.subtract = function subtract(subtrahend) {\n        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    };\n    /**\n   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n   * @function\n   * @param {!Long|number|bigint|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */ LongPrototype.sub = LongPrototype.subtract;\n    /**\n   * Returns the product of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */ LongPrototype.multiply = function multiply(multiplier) {\n        if (this.isZero()) return this;\n        if (!isLong(multiplier)) multiplier = fromValue(multiplier);\n        // use wasm support if present\n        if (wasm) {\n            var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n            else return this.neg().mul(multiplier).neg();\n        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n        // If both longs are small, use float multiplication\n        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n        // We can skip products that would overflow.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xFFFF;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xFFFF;\n        var b48 = multiplier.high >>> 16;\n        var b32 = multiplier.high & 0xFFFF;\n        var b16 = multiplier.low >>> 16;\n        var b00 = multiplier.low & 0xFFFF;\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xFFFF;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xFFFF;\n        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    /**\n   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n   * @function\n   * @param {!Long|number|bigint|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */ LongPrototype.mul = LongPrototype.multiply;\n    /**\n   * Returns this Long divided by the specified. The result is signed if this Long is signed or\n   *  unsigned if this Long is unsigned.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */ LongPrototype.divide = function divide(divisor) {\n        if (!isLong(divisor)) divisor = fromValue(divisor);\n        if (divisor.isZero()) throw Error(\"division by zero\");\n        // use wasm support if present\n        if (wasm) {\n            // guard against signed division overflow: the largest\n            // negative number / -1 would be 1 larger than the largest\n            // positive number, due to two's complement.\n            if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n                // be consistent with non-wasm code path\n                return this;\n            }\n            var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(this.low, this.high, divisor.low, divisor.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n        var approx, rem, res;\n        if (!this.unsigned) {\n            // This section is only relevant for signed longs and is derived from the\n            // closure library as a whole.\n            if (this.eq(MIN_VALUE)) {\n                if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n                else if (divisor.eq(MIN_VALUE)) return ONE;\n                else {\n                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                    var halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(ZERO)) {\n                        return divisor.isNegative() ? ONE : NEG_ONE;\n                    } else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative()) return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n            res = ZERO;\n        } else {\n            // The algorithm below has not been made for unsigned longs. It's therefore\n            // required to take special care of the MSB prior to running it.\n            if (!divisor.unsigned) divisor = divisor.toUnsigned();\n            if (divisor.gt(this)) return UZERO;\n            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n            return UONE;\n            res = UZERO;\n        }\n        // Repeat the following until the remainder is less than other:  find a\n        // floating-point that approximates remainder / other *from below*, add this\n        // into the result, and subtract it from the remainder.  It is critical that\n        // the approximate value is less than or equal to the real value so that the\n        // remainder never becomes negative.\n        rem = this;\n        while(rem.gte(divisor)){\n            // Approximate the result of division. This may be a little greater or\n            // smaller than the actual value.\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n            // We will tweak the approximate result by changing it in the 48-th digit or\n            // the smallest non-fractional digit, whichever is larger.\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), // Decrease the approximation until it is smaller than the remainder.  Note\n            // that if it is too large, the product overflows and is negative.\n            approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n            while(approxRem.isNegative() || approxRem.gt(rem)){\n                approx -= delta;\n                approxRes = fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            }\n            // We know the answer can't be zero... and actually, zero would cause\n            // infinite recursion since we would make no progress.\n            if (approxRes.isZero()) approxRes = ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    };\n    /**\n   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n   * @function\n   * @param {!Long|number|bigint|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */ LongPrototype.div = LongPrototype.divide;\n    /**\n   * Returns this Long modulo the specified.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.modulo = function modulo(divisor) {\n        if (!isLong(divisor)) divisor = fromValue(divisor);\n        // use wasm support if present\n        if (wasm) {\n            var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(this.low, this.high, divisor.low, divisor.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    };\n    /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|bigint|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.mod = LongPrototype.modulo;\n    /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|bigint|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.rem = LongPrototype.modulo;\n    /**\n   * Returns the bitwise NOT of this Long.\n   * @this {!Long}\n   * @returns {!Long}\n   */ LongPrototype.not = function not() {\n        return fromBits(~this.low, ~this.high, this.unsigned);\n    };\n    /**\n   * Returns count leading zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */ LongPrototype.countLeadingZeros = function countLeadingZeros() {\n        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n    };\n    /**\n   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */ LongPrototype.clz = LongPrototype.countLeadingZeros;\n    /**\n   * Returns count trailing zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */ LongPrototype.countTrailingZeros = function countTrailingZeros() {\n        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n    };\n    /**\n   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */ LongPrototype.ctz = LongPrototype.countTrailingZeros;\n    /**\n   * Returns the bitwise AND of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.and = function and(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    };\n    /**\n   * Returns the bitwise OR of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.or = function or(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    };\n    /**\n   * Returns the bitwise XOR of this Long and the given one.\n   * @this {!Long}\n   * @param {!Long|number|bigint|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.xor = function xor(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits shifted to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftLeft = function shiftLeft(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n        else return fromBits(0, this.low << numBits - 32, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shl = LongPrototype.shiftLeft;\n    /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftRight = function shiftRight(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n        else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shr = LongPrototype.shiftRight;\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);\n        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n    /**\n   * Returns this Long with bits rotated to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotateLeft = function rotateLeft(numBits) {\n        var b;\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n        if (numBits < 32) {\n            b = 32 - numBits;\n            return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);\n        }\n        numBits -= 32;\n        b = 32 - numBits;\n        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotl = LongPrototype.rotateLeft;\n    /**\n   * Returns this Long with bits rotated to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotateRight = function rotateRight(numBits) {\n        var b;\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n        if (numBits < 32) {\n            b = 32 - numBits;\n            return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);\n        }\n        numBits -= 32;\n        b = 32 - numBits;\n        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotr = LongPrototype.rotateRight;\n    /**\n   * Converts this Long to signed.\n   * @this {!Long}\n   * @returns {!Long} Signed long\n   */ LongPrototype.toSigned = function toSigned() {\n        if (!this.unsigned) return this;\n        return fromBits(this.low, this.high, false);\n    };\n    /**\n   * Converts this Long to unsigned.\n   * @this {!Long}\n   * @returns {!Long} Unsigned long\n   */ LongPrototype.toUnsigned = function toUnsigned() {\n        if (this.unsigned) return this;\n        return fromBits(this.low, this.high, true);\n    };\n    /**\n   * Converts this Long to its byte representation.\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @this {!Long}\n   * @returns {!Array.<number>} Byte representation\n   */ LongPrototype.toBytes = function toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    };\n    /**\n   * Converts this Long to its little endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Little endian byte representation\n   */ LongPrototype.toBytesLE = function toBytesLE() {\n        var hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            lo >>> 8 & 0xff,\n            lo >>> 16 & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            hi >>> 8 & 0xff,\n            hi >>> 16 & 0xff,\n            hi >>> 24\n        ];\n    };\n    /**\n   * Converts this Long to its big endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Big endian byte representation\n   */ LongPrototype.toBytesBE = function toBytesBE() {\n        var hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            hi >>> 16 & 0xff,\n            hi >>> 8 & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            lo >>> 16 & 0xff,\n            lo >>> 8 & 0xff,\n            lo & 0xff\n        ];\n    };\n    /**\n   * Creates a Long from its byte representation.\n   * @param {!Array.<number>} bytes Byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytes = function fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    };\n    /**\n   * Creates a Long from its little endian byte representation.\n   * @param {!Array.<number>} bytes Little endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n    };\n    /**\n   * Creates a Long from its big endian byte representation.\n   * @param {!Array.<number>} bytes Big endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n    };\n    // Support conversion to/from BigInt where available\n    if (typeof BigInt === \"function\") {\n        /**\n     * Returns a Long representing the given big integer.\n     * @function\n     * @param {number} value The big integer value\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n     * @returns {!Long} The corresponding Long value\n     */ Long.fromBigInt = function fromBigInt1(value, unsigned) {\n            var lowBits = Number(BigInt.asIntN(32, value));\n            var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));\n            return fromBits(lowBits, highBits, unsigned);\n        };\n        // Override\n        Long.fromValue = function fromValueWithBigInt(value, unsigned) {\n            if (typeof value === \"bigint\") return fromBigInt(value, unsigned);\n            return fromValue(value, unsigned);\n        };\n        /**\n     * Converts the Long to its big integer representation.\n     * @this {!Long}\n     * @returns {bigint}\n     */ LongPrototype.toBigInt = function toBigInt() {\n            var lowBigInt = BigInt(this.low >>> 0);\n            var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);\n            return highBigInt << BigInt(32) | lowBigInt;\n        };\n    }\n    var _default = exports1.default = Long;\n    return \"default\" in exports1 ? exports1.default : exports1;\n}({});\nif (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n    return Long;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\nelse {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG9uZy91bWQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsK0ZBQStCOztBQUMvQixJQUFJQSxPQUFPLFNBQVVDLFFBQU87SUFDMUI7SUFFQUMsT0FBT0MsY0FBYyxDQUFDRixVQUFTLGNBQWM7UUFDM0NHLE9BQU87SUFDVDtJQUNBSCxTQUFRSSxPQUFPLEdBQUcsS0FBSztJQUN2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JDLEdBRUQsdUVBQXVFO0lBQ3ZFLElBQUlDLE9BQU87SUFDWCxJQUFJO1FBQ0ZBLE9BQU8sSUFBSUMsWUFBWUMsUUFBUSxDQUFDLElBQUlELFlBQVlFLE1BQU0sQ0FBQyxJQUFJQyxXQUFXO1lBQ3RFLFFBQVE7WUFDUjtZQUFHO1lBQUk7WUFBSztZQUNaLFlBQVk7WUFDWjtZQUFHO1lBQUc7WUFBRztZQUNULGlCQUFpQjtZQUNqQjtZQUFHO1lBQUk7WUFDUCxlQUFlO1lBQ2Y7WUFBSTtZQUFHO1lBQUc7WUFDVixpQ0FBaUM7WUFDakM7WUFBSTtZQUFHO1lBQUs7WUFBSztZQUFLO1lBQUs7WUFBRztZQUM5QixxQkFBcUI7WUFDckI7WUFBRztZQUFHO1lBQ04sWUFBWTtZQUNaO1lBQ0EsWUFBWTtZQUNaO1lBQ0EsWUFBWTtZQUNaO1lBQ0EsWUFBWTtZQUNaO1lBQ0EsWUFBWTtZQUNaO1lBQ0EsWUFBWTtZQUNaO1lBQ0EsbUJBQW1CO1lBQ25CO1lBQUc7WUFBRztZQUNOLHlCQUF5QjtZQUN6QjtZQUFLO1lBQUc7WUFBSTtZQUFHO1lBQ2YsbUJBQW1CO1lBQ25CO1lBQUc7WUFBSTtZQUNQLFdBQVc7WUFDWDtZQUFHO1lBQUs7WUFBSztZQUFLO1lBQUc7WUFDckIsYUFBYTtZQUNiO1lBQUc7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFLO1lBQUc7WUFDOUIsYUFBYTtZQUNiO1lBQUc7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFLO1lBQUc7WUFDOUIsYUFBYTtZQUNiO1lBQUc7WUFBSztZQUFLO1lBQUs7WUFBSTtZ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QU9ULFVBQVUsVUFBVSxPQUFPa0wsV0FBV2xMLE9BQU9TO1lBQ3hELE9BQU9nRCxVQUFVekQsT0FBT1M7UUFDMUI7UUFFQTs7OztLQUlDLEdBQ0R3RCxjQUFjcUgsUUFBUSxHQUFHLFNBQVNBO1lBQ2hDLElBQUlDLFlBQVlOLE9BQU8sSUFBSSxDQUFDMUssR0FBRyxLQUFLO1lBQ3BDLElBQUlpTCxhQUFhUCxPQUFPLElBQUksQ0FBQ3hLLFFBQVEsR0FBRyxJQUFJLENBQUNELElBQUksS0FBSyxJQUFJLElBQUksQ0FBQ0EsSUFBSTtZQUNuRSxPQUFPZ0wsY0FBY1AsT0FBTyxNQUFNTTtRQUNwQztJQUNGO0lBQ0EsSUFBSUUsV0FBVzVMLFNBQVFJLE9BQU8sR0FBR0w7SUFDakMsT0FBTyxhQUFhQyxXQUFVQSxTQUFRSSxPQUFPLEdBQUdKO0FBQ2xELEVBQUcsQ0FBQztBQUNKLElBQUksSUFBMEMsRUFBRTZMLGlDQUFPLEVBQUUsbUNBQUU7SUFBYSxPQUFPOUw7QUFBTSxDQUFDO0FBQUEsa0dBQUM7S0FDbEYsRUFBcUZBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcWlydGFhcy1wdWJsaWNhdGlvbnMvLi9ub2RlX21vZHVsZXMvbG9uZy91bWQvaW5kZXguanM/ZGM0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHRU5FUkFURUQgRklMRS4gRE8gTk9UIEVESVQuXG52YXIgTG9uZyA9IChmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9yc1xuICAgKiBDb3B5cmlnaHQgMjAyMCBEYW5pZWwgV2lydHogLyBUaGUgbG9uZy5qcyBBdXRob3JzLlxuICAgKlxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgKlxuICAgKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAqXG4gICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICpcbiAgICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAgICovXG4gIFxuICAvLyBXZWJBc3NlbWJseSBvcHRpbWl6YXRpb25zIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxuICB2YXIgd2FzbSA9IG51bGw7XG4gIHRyeSB7XG4gICAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFtcbiAgICAvLyBcXDBhc21cbiAgICAwLCA5NywgMTE1LCAxMDksXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMSwgMCwgMCwgMCxcbiAgICAvLyBzZWN0aW9uIFwidHlwZVwiXG4gICAgMSwgMTMsIDIsXG4gICAgLy8gMCwgKCkgPT4gaTMyXG4gICAgOTYsIDAsIDEsIDEyNyxcbiAgICAvLyAxLCAoaTMyLCBpMzIsIGkzMiwgaTMyKSA9PiBpMzJcbiAgICA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsXG4gICAgLy8gc2VjdGlvbiBcImZ1bmN0aW9uXCJcbiAgICAzLCA3LCA2LFxuICAgIC8vIDAsIHR5cGUgMFxuICAgIDAsXG4gICAgLy8gMSwgdHlwZSAxXG4gICAgMSxcbiAgICAvLyAyLCB0eXBlIDFcbiAgICAxLFxuICAgIC8vIDMsIHR5cGUgMVxuICAgIDEsXG4gICAgLy8gNCwgdHlwZSAxXG4gICAgMSxcbiAgICAvLyA1LCB0eXBlIDFcbiAgICAxLFxuICAgIC8vIHNlY3Rpb24gXCJnbG9iYWxcIlxuICAgIDYsIDYsIDEsXG4gICAgLy8gMCwgXCJoaWdoXCIsIG11dGFibGUgaTMyXG4gICAgMTI3LCAxLCA2NSwgMCwgMTEsXG4gICAgLy8gc2VjdGlvbiBcImV4cG9ydFwiXG4gICAgNywgNTAsIDYsXG4gICAgLy8gMCwgXCJtdWxcIlxuICAgIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsXG4gICAgLy8gMSwgXCJkaXZfc1wiXG4gICAgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMixcbiAgICAvLyAyLCBcImRpdl91XCJcbiAgICA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE3LCAwLCAzLFxuICAgIC8vIDMsIFwicmVtX3NcIlxuICAgIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsXG4gICAgLy8gNCwgXCJyZW1fdVwiXG4gICAgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSxcbiAgICAvLyA1LCBcImdldF9oaWdoXCJcbiAgICA4LCAxMDMsIDEwMSwgMTE2LCA5NSwgMTA0LCAxMDUsIDEwMywgMTA0LCAwLCAwLFxuICAgIC8vIHNlY3Rpb24gXCJjb2RlXCJcbiAgICAxMCwgMTkxLCAxLCA2LFxuICAgIC8vIDAsIFwiZ2V0X2hpZ2hcIlxuICAgIDQsIDAsIDM1LCAwLCAxMSxcbiAgICAvLyAxLCBcIm11bFwiXG4gICAgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLFxuICAgIC8vIDIsIFwiZGl2X3NcIlxuICAgIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSxcbiAgICAvLyAzLCBcImRpdl91XCJcbiAgICAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjgsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsXG4gICAgLy8gNCwgXCJyZW1fc1wiXG4gICAgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLFxuICAgIC8vIDUsIFwicmVtX3VcIlxuICAgIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMV0pKSwge30pLmV4cG9ydHM7XG4gIH0gY2F0Y2gge1xuICAgIC8vIG5vIHdhc20gc3VwcG9ydCA6KFxuICB9XG4gIFxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIsIGdpdmVuIGl0cyBsb3cgYW5kIGhpZ2ggMzIgYml0IHZhbHVlcyBhcyAqc2lnbmVkKiBpbnRlZ2Vycy5cbiAgICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXG4gICAqIEBleHBvcnRzIExvbmdcbiAgICogQGNsYXNzIEEgTG9uZyBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gTG9uZyhsb3csIGhpZ2gsIHVuc2lnbmVkKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuICBcbiAgICAvKipcbiAgICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG4gIFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xuICB9XG4gIFxuICAvLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxuICAvLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxuICAvLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcbiAgLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxuICAvLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xuICAvLyBvciBjaGFuZ2UgaW4gc2lnbi5cbiAgLy9cbiAgLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxuICAvLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cbiAgLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXG4gIC8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcbiAgLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xuICAvLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vXG4gIC8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxuICAvLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxuICBcbiAgLyoqXG4gICAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBjb25zdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBpbm5lclxuICAgKi9cbiAgZnVuY3Rpb24gaXNMb25nKG9iaikge1xuICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xuICB9XG4gIFxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgbnVtYmVyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgZnVuY3Rpb24gY3R6MzIodmFsdWUpIHtcbiAgICB2YXIgYyA9IE1hdGguY2x6MzIodmFsdWUgJiAtdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZSA/IDMxIC0gYyA6IGM7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBMb25nLmlzTG9uZyA9IGlzTG9uZztcbiAgXG4gIC8qKlxuICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCBpbnRlZ2VyIHZhbHVlcy5cbiAgICogQHR5cGUgeyFPYmplY3R9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgdmFyIElOVF9DQUNIRSA9IHt9O1xuICBcbiAgLyoqXG4gICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLlxuICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICogQGlubmVyXG4gICAqL1xuICB2YXIgVUlOVF9DQUNIRSA9IHt9O1xuICBcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xuICAgIGlmICh1bnNpZ25lZCkge1xuICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgaWYgKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1Nikge1xuICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgICAgaWYgKGNhY2hlZE9iaikgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgIH1cbiAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAwLCB0cnVlKTtcbiAgICAgIGlmIChjYWNoZSkgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSB8PSAwO1xuICAgICAgaWYgKGNhY2hlID0gLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkge1xuICAgICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgICBpZiAoY2FjaGVkT2JqKSByZXR1cm4gY2FjaGVkT2JqO1xuICAgICAgfVxuICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgICAgaWYgKGNhY2hlKSBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgTG9uZy5mcm9tSW50ID0gZnJvbUludDtcbiAgXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgIGlmICh1bnNpZ25lZCkge1xuICAgICAgaWYgKHZhbHVlIDwgMCkgcmV0dXJuIFVaRVJPO1xuICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKSByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKSByZXR1cm4gTUlOX1ZBTFVFO1xuICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTCkgcmV0dXJuIE1BWF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgMCkgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XG4gICAgcmV0dXJuIGZyb21CaXRzKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCB2YWx1ZSAvIFRXT19QV1JfMzJfREJMIHwgMCwgdW5zaWduZWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBMb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xuICBcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0IGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcbiAgICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIExvbmcuZnJvbUJpdHMgPSBmcm9tQml0cztcbiAgXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgdmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcbiAgXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xuICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxuICAgICAgcmFkaXggPSB1bnNpZ25lZDtcbiAgICAgIHVuc2lnbmVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZDtcbiAgICB9XG4gICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKSByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG4gICAgdmFyIHA7XG4gICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKSB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7ZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcbiAgICB9XG4gIFxuICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7XG4gICAgdmFyIHJlc3VsdCA9IFpFUk87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxuICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7XG4gICAgICBpZiAoc2l6ZSA8IDgpIHtcbiAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgTG9uZ1xuICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIExvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG4gIFxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBmdW5jdGlvbiBmcm9tVmFsdWUodmFsLCB1bnNpZ25lZCkge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTtcbiAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxuICAgIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAnYm9vbGVhbicgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZyB1c2luZyB0aGUgYXBwcm9wcmlhdGUgZnJvbSogZnVuY3Rpb24gZm9yIGl0cyB0eXBlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsIFZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKi9cbiAgTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XG4gIFxuICAvLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXG4gIC8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXG4gIFxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgdmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcbiAgXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICB2YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xuICBcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIHZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XG4gIFxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgdmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcbiAgXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICB2YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XG4gIFxuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuICBcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICB2YXIgWkVSTyA9IGZyb21JbnQoMCk7XG4gIFxuICAvKipcbiAgICogU2lnbmVkIHplcm8uXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIExvbmcuWkVSTyA9IFpFUk87XG4gIFxuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIHZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XG4gIFxuICAvKipcbiAgICogVW5zaWduZWQgemVyby5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgTG9uZy5VWkVSTyA9IFVaRVJPO1xuICBcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICB2YXIgT05FID0gZnJvbUludCgxKTtcbiAgXG4gIC8qKlxuICAgKiBTaWduZWQgb25lLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBMb25nLk9ORSA9IE9ORTtcbiAgXG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgdmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xuICBcbiAgLyoqXG4gICAqIFVuc2lnbmVkIG9uZS5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgTG9uZy5VT05FID0gVU9ORTtcbiAgXG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgdmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcbiAgXG4gIC8qKlxuICAgKiBTaWduZWQgbmVnYXRpdmUgb25lLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBMb25nLk5FR19PTkUgPSBORUdfT05FO1xuICBcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICB2YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4N0ZGRkZGRkYgfCAwLCBmYWxzZSk7XG4gIFxuICAvKipcbiAgICogTWF4aW11bSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIExvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xuICBcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICB2YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4RkZGRkZGRkYgfCAwLCB0cnVlKTtcbiAgXG4gIC8qKlxuICAgKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBMb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcbiAgXG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgdmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XG4gIFxuICAvKipcbiAgICogTWluaW11bSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIExvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xuICBcbiAgLyoqXG4gICAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxuICAgKiBAaW5uZXJcbiAgICovXG4gIHZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XG4gIFxuICAvKipcbiAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xuICAgIGlmICh0aGlzLnVuc2lnbmVkKSByZXR1cm4gKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAnMCc7XG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcbiAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcbiAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxuICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXG4gICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcbiAgICAgICAgICByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xuICAgICAgfSBlbHNlIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICB9XG4gIFxuICAgIC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksXG4gICAgICByZW0gPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcbiAgICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXG4gICAgICAgIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XG4gICAgICByZW0gPSByZW1EaXY7XG4gICAgICBpZiAocmVtLmlzWmVybygpKSByZXR1cm4gZGlnaXRzICsgcmVzdWx0O2Vsc2Uge1xuICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpIGRpZ2l0cyA9ICcwJyArIGRpZ2l0cztcbiAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBcbiAgLyoqXG4gICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcbiAgICovXG4gIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXG4gICAqL1xuICBMb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xuICAgIHJldHVybiB0aGlzLmxvdztcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXG4gICAqL1xuICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XG4gIH07XG4gIFxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBMb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSlcbiAgICAgIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxuICAgICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XG4gICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XG4gICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKSBpZiAoKHZhbCAmIDEgPDwgYml0KSAhPSAwKSBicmVhaztcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XG4gIH07XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nIGNhbiBiZSBzYWZlbHkgcmVwcmVzZW50ZWQgYXMgYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUuaXNTYWZlSW50ZWdlciA9IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIoKSB7XG4gICAgLy8gMl41My0xIGlzIHRoZSBtYXhpbXVtIHNhZmUgdmFsdWVcbiAgICB2YXIgdG9wMTFCaXRzID0gdGhpcy5oaWdoID4+IDIxO1xuICAgIC8vIFswLCAyXjUzLTFdXG4gICAgaWYgKCF0b3AxMUJpdHMpIHJldHVybiB0cnVlO1xuICAgIC8vID4gMl41My0xXG4gICAgaWYgKHRoaXMudW5zaWduZWQpIHJldHVybiBmYWxzZTtcbiAgICAvLyBbLTJeNTMsIC0xXSBleGNlcHQgLTJeNTNcbiAgICByZXR1cm4gdG9wMTFCaXRzID09PSAtMSAmJiAhKHRoaXMubG93ID09PSAwICYmIHRoaXMuaGlnaCA9PT0gLTB4MjAwMDAwKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XG4gIH07XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjaXNaZXJvfS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBMb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xuICBcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcbiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZSBvciB6ZXJvLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBMb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGV2ZW4uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBMb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XG4gIH07XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XG4gIH07XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBMb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuICF0aGlzLmVxKC8qIHZhbGlkYXRlcyAqL290aGVyKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBMb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovb3RoZXIpIDwgMDtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi9vdGhlcikgPD0gMDtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUubHRlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBMb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovb3RoZXIpID4gMDtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi9vdGhlcikgPj0gMDtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XG4gIFxuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBMb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XG4gIFxuICAvKipcbiAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gICAqL1xuICBMb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMuZXEob3RoZXIpKSByZXR1cm4gMDtcbiAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxuICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XG4gICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKSByZXR1cm4gLTE7XG4gICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKSByZXR1cm4gMTtcbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcbiAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcbiAgICByZXR1cm4gb3RoZXIuaGlnaCA+Pj4gMCA+IHRoaXMuaGlnaCA+Pj4gMCB8fCBvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDAgPyAtMSA6IDE7XG4gIH07XG4gIFxuICAvKipcbiAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXG4gICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAgICovXG4gIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcbiAgXG4gIC8qKlxuICAgKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gICAqL1xuICBMb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKSByZXR1cm4gTUlOX1ZBTFVFO1xuICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gICAqL1xuICBMb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xuICBcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gYWRkZW5kIEFkZGVuZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFN1bVxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSkgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XG4gIFxuICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxuICBcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XG4gICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcbiAgICB2YXIgYzQ4ID0gMCxcbiAgICAgIGMzMiA9IDAsXG4gICAgICBjMTYgPSAwLFxuICAgICAgYzAwID0gMDtcbiAgICBjMDAgKz0gYTAwICsgYjAwO1xuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgIGMwMCAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGExNiArIGIxNjtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMzIgKyBiMzI7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjNDggKz0gYTQ4ICsgYjQ4O1xuICAgIGM0OCAmPSAweEZGRkY7XG4gICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcbiAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXG4gICAqL1xuICBMb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKSBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xuICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcbiAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXG4gICAqL1xuICBMb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XG4gIFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7XG4gIFxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICAgIGlmICh3YXNtKSB7XG4gICAgICB2YXIgbG93ID0gd2FzbVtcIm11bFwiXSh0aGlzLmxvdywgdGhpcy5oaWdoLCBtdWx0aXBsaWVyLmxvdywgbXVsdGlwbGllci5oaWdoKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xuICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7ZWxzZSByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XG4gICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xuICBcbiAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXG4gICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSkgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcbiAgXG4gICAgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXG4gICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cbiAgXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcbiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcbiAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XG4gICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xuICAgIHZhciBjNDggPSAwLFxuICAgICAgYzMyID0gMCxcbiAgICAgIGMxNiA9IDAsXG4gICAgICBjMDAgPSAwO1xuICAgIGMwMCArPSBhMDAgKiBiMDA7XG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgYzAwICY9IDB4RkZGRjtcbiAgICBjMTYgKz0gYTE2ICogYjAwO1xuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgIGMxNiAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMzIgKiBiMDA7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjMzIgKz0gYTE2ICogYjE2O1xuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgIGMzMiAmPSAweEZGRkY7XG4gICAgYzMyICs9IGEwMCAqIGIzMjtcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICBjMzIgJj0gMHhGRkZGO1xuICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gICAgYzQ4ICY9IDB4RkZGRjtcbiAgICByZXR1cm4gZnJvbUJpdHMoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAgICovXG4gIExvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcbiAgICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKSBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgIGlmIChkaXZpc29yLmlzWmVybygpKSB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpO1xuICBcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgICBpZiAod2FzbSkge1xuICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzaWduZWQgZGl2aXNpb24gb3ZlcmZsb3c6IHRoZSBsYXJnZXN0XG4gICAgICAvLyBuZWdhdGl2ZSBudW1iZXIgLyAtMSB3b3VsZCBiZSAxIGxhcmdlciB0aGFuIHRoZSBsYXJnZXN0XG4gICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxuICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiYgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcbiAgICAgICAgLy8gYmUgY29uc2lzdGVudCB3aXRoIG5vbi13YXNtIGNvZGUgcGF0aFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc21bXCJkaXZfdVwiXSA6IHdhc21bXCJkaXZfc1wiXSkodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7XG4gICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcbiAgICAgIC8vIFRoaXMgc2VjdGlvbiBpcyBvbmx5IHJlbGV2YW50IGZvciBzaWduZWQgbG9uZ3MgYW5kIGlzIGRlcml2ZWQgZnJvbSB0aGVcbiAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxuICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpIHJldHVybiBNSU5fVkFMVUU7IC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXG4gICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIE9ORTtlbHNlIHtcbiAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXG4gICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XG4gICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcbiAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7XG4gICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUgOiBORUdfT05FO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcbiAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XG4gICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XG4gICAgICByZXMgPSBaRVJPO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcbiAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cbiAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZCkgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xuICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpIHJldHVybiBVWkVSTztcbiAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpXG4gICAgICAgIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXG4gICAgICAgIHJldHVybiBVT05FO1xuICAgICAgcmVzID0gVVpFUk87XG4gICAgfVxuICBcbiAgICAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxuICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcbiAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XG4gICAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxuICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxuICAgIHJlbSA9IHRoaXM7XG4gICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHtcbiAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcbiAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxuICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpO1xuICBcbiAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcbiAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cbiAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXG4gICAgICAgIGRlbHRhID0gbG9nMiA8PSA0OCA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXG4gICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxuICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cbiAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxuICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcbiAgICAgICAgYXBwcm94IC09IGRlbHRhO1xuICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgICB9XG4gIFxuICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXG4gICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cbiAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpIGFwcHJveFJlcyA9IE9ORTtcbiAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcbiAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XG4gICAqL1xuICBMb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xuICBcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKSBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xuICBcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgICBpZiAod2FzbSkge1xuICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcInJlbV91XCJdIDogd2FzbVtcInJlbV9zXCJdKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XG4gIH07XG4gIFxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5tb2QgPSBMb25nUHJvdG90eXBlLm1vZHVsbztcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gICAqL1xuICBMb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuICBcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcbiAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcyA9IGZ1bmN0aW9uIGNvdW50TGVhZGluZ1plcm9zKCkge1xuICAgIHJldHVybiB0aGlzLmhpZ2ggPyBNYXRoLmNsejMyKHRoaXMuaGlnaCkgOiBNYXRoLmNsejMyKHRoaXMubG93KSArIDMyO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIFJldHVybnMgY291bnQgbGVhZGluZyB6ZXJvcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb3VudExlYWRpbmdaZXJvc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfVxuICAgKiBAcmV0dXJucyB7IW51bWJlcn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUuY2x6ID0gTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcztcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IHRyYWlsaW5nIHplcm9zIG9mIHRoaXMgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IW51bWJlcn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKCkge1xuICAgIHJldHVybiB0aGlzLmxvdyA/IGN0ejMyKHRoaXMubG93KSA6IGN0ejMyKHRoaXMuaGlnaCkgKyAzMjtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IHRyYWlsaW5nIHplcm9zLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvdW50VHJhaWxpbmdaZXJvc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfVxuICAgKiBAcmV0dXJucyB7IW51bWJlcn1cbiAgICovXG4gIExvbmdQcm90b3R5cGUuY3R6ID0gTG9uZ1Byb3RvdHlwZS5jb3VudFRyYWlsaW5nWmVyb3M7XG4gIFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBMb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIFxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7ZWxzZSBpZiAobnVtQml0cyA8IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgdGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gMzIgLSBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtlbHNlIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCBudW1CaXRzIC0gMzIsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBMb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0O1xuICBcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO2Vsc2UgaWYgKG51bUJpdHMgPCAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ID4+PiBudW1CaXRzIHwgdGhpcy5oaWdoIDw8IDMyIC0gbnVtQml0cywgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO2Vsc2UgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiBudW1CaXRzIC0gMzIsIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBMb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChudW1CaXRzIDwgMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gICAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+PiBudW1CaXRzIC0gMzIsIDAsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xuICBcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIExvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gICAqL1xuICBMb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiByb3RhdGVMZWZ0KG51bUJpdHMpIHtcbiAgICB2YXIgYjtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpO1xuICAgIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cyB8IHRoaXMuaGlnaCA+Pj4gYiwgdGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gYiwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIG51bUJpdHMgLT0gMzI7XG4gICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gYiwgdGhpcy5sb3cgPDwgbnVtQml0cyB8IHRoaXMuaGlnaCA+Pj4gYiwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3JvdGF0ZUxlZnR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIExvbmdQcm90b3R5cGUucm90bCA9IExvbmdQcm90b3R5cGUucm90YXRlTGVmdDtcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5yb3RhdGVSaWdodCA9IGZ1bmN0aW9uIHJvdGF0ZVJpZ2h0KG51bUJpdHMpIHtcbiAgICB2YXIgYjtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpO1xuICAgIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoIDw8IGIgfCB0aGlzLmxvdyA+Pj4gbnVtQml0cywgdGhpcy5sb3cgPDwgYiB8IHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIG51bUJpdHMgLT0gMzI7XG4gICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgYiB8IHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy5oaWdoIDw8IGIgfCB0aGlzLmxvdyA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNyb3RhdGVSaWdodH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS5yb3RyID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVSaWdodDtcbiAgXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gc2lnbmVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcbiAgICovXG4gIExvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XG4gIH07XG4gIFxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xuICAgKi9cbiAgTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcbiAgICBpZiAodGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIExvbmdQcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMobGUpIHtcbiAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIExvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFKCkge1xuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICAgIGxvID0gdGhpcy5sb3c7XG4gICAgcmV0dXJuIFtsbyAmIDB4ZmYsIGxvID4+PiA4ICYgMHhmZiwgbG8gPj4+IDE2ICYgMHhmZiwgbG8gPj4+IDI0LCBoaSAmIDB4ZmYsIGhpID4+PiA4ICYgMHhmZiwgaGkgPj4+IDE2ICYgMHhmZiwgaGkgPj4+IDI0XTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIExvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICAgIGxvID0gdGhpcy5sb3c7XG4gICAgcmV0dXJuIFtoaSA+Pj4gMjQsIGhpID4+PiAxNiAmIDB4ZmYsIGhpID4+PiA4ICYgMHhmZiwgaGkgJiAweGZmLCBsbyA+Pj4gMjQsIGxvID4+PiAxNiAmIDB4ZmYsIGxvID4+PiA4ICYgMHhmZiwgbG8gJiAweGZmXTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQnl0ZSByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cbiAgICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIExvbmcuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHtcbiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XG4gIH07XG4gIFxuICAvKipcbiAgICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIExvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcbiAgICByZXR1cm4gbmV3IExvbmcoYnl0ZXNbMF0gfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1szXSA8PCAyNCwgYnl0ZXNbNF0gfCBieXRlc1s1XSA8PCA4IHwgYnl0ZXNbNl0gPDwgMTYgfCBieXRlc1s3XSA8PCAyNCwgdW5zaWduZWQpO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBMb25nLmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzRdIDw8IDI0IHwgYnl0ZXNbNV0gPDwgMTYgfCBieXRlc1s2XSA8PCA4IHwgYnl0ZXNbN10sIGJ5dGVzWzBdIDw8IDI0IHwgYnl0ZXNbMV0gPDwgMTYgfCBieXRlc1syXSA8PCA4IHwgYnl0ZXNbM10sIHVuc2lnbmVkKTtcbiAgfTtcbiAgXG4gIC8vIFN1cHBvcnQgY29udmVyc2lvbiB0by9mcm9tIEJpZ0ludCB3aGVyZSBhdmFpbGFibGVcbiAgaWYgKHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gYmlnIGludGVnZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBiaWcgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICAgKi9cbiAgICBMb25nLmZyb21CaWdJbnQgPSBmdW5jdGlvbiBmcm9tQmlnSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgdmFyIGxvd0JpdHMgPSBOdW1iZXIoQmlnSW50LmFzSW50TigzMiwgdmFsdWUpKTtcbiAgICAgIHZhciBoaWdoQml0cyA9IE51bWJlcihCaWdJbnQuYXNJbnROKDMyLCB2YWx1ZSA+PiBCaWdJbnQoMzIpKSk7XG4gICAgICByZXR1cm4gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbiAgICB9O1xuICBcbiAgICAvLyBPdmVycmlkZVxuICAgIExvbmcuZnJvbVZhbHVlID0gZnVuY3Rpb24gZnJvbVZhbHVlV2l0aEJpZ0ludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHJldHVybiBmcm9tQmlnSW50KHZhbHVlLCB1bnNpZ25lZCk7XG4gICAgICByZXR1cm4gZnJvbVZhbHVlKHZhbHVlLCB1bnNpZ25lZCk7XG4gICAgfTtcbiAgXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gaXRzIGJpZyBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUudG9CaWdJbnQgPSBmdW5jdGlvbiB0b0JpZ0ludCgpIHtcbiAgICAgIHZhciBsb3dCaWdJbnQgPSBCaWdJbnQodGhpcy5sb3cgPj4+IDApO1xuICAgICAgdmFyIGhpZ2hCaWdJbnQgPSBCaWdJbnQodGhpcy51bnNpZ25lZCA/IHRoaXMuaGlnaCA+Pj4gMCA6IHRoaXMuaGlnaCk7XG4gICAgICByZXR1cm4gaGlnaEJpZ0ludCA8PCBCaWdJbnQoMzIpIHwgbG93QmlnSW50O1xuICAgIH07XG4gIH1cbiAgdmFyIF9kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0ID0gTG9uZztcbiAgcmV0dXJuIFwiZGVmYXVsdFwiIGluIGV4cG9ydHMgPyBleHBvcnRzLmRlZmF1bHQgOiBleHBvcnRzO1xufSkoe30pO1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIExvbmc7IH0pO1xuZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSBtb2R1bGUuZXhwb3J0cyA9IExvbmc7XG4iXSwibmFtZXMiOlsiTG9uZyIsImV4cG9ydHMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZGVmYXVsdCIsIndhc20iLCJXZWJBc3NlbWJseSIsIkluc3RhbmNlIiwiTW9kdWxlIiwiVWludDhBcnJheSIsImxvdyIsImhpZ2giLCJ1bnNpZ25lZCIsInByb3RvdHlwZSIsIl9faXNMb25nX18iLCJpc0xvbmciLCJvYmoiLCJjdHozMiIsImMiLCJNYXRoIiwiY2x6MzIiLCJJTlRfQ0FDSEUiLCJVSU5UX0NBQ0hFIiwiZnJvbUludCIsImNhY2hlZE9iaiIsImNhY2hlIiwiZnJvbUJpdHMiLCJmcm9tTnVtYmVyIiwiaXNOYU4iLCJVWkVSTyIsIlpFUk8iLCJUV09fUFdSXzY0X0RCTCIsIk1BWF9VTlNJR05FRF9WQUxVRSIsIlRXT19QV1JfNjNfREJMIiwiTUlOX1ZBTFVFIiwiTUFYX1ZBTFVFIiwibmVnIiwiVFdPX1BXUl8zMl9EQkwiLCJsb3dCaXRzIiwiaGlnaEJpdHMiLCJwb3dfZGJsIiwicG93IiwiZnJvbVN0cmluZyIsInN0ciIsInJhZGl4IiwibGVuZ3RoIiwiRXJyb3IiLCJSYW5nZUVycm9yIiwicCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJyYWRpeFRvUG93ZXIiLCJyZXN1bHQiLCJpIiwic2l6ZSIsIm1pbiIsInBhcnNlSW50IiwicG93ZXIiLCJtdWwiLCJhZGQiLCJmcm9tVmFsdWUiLCJ2YWwiLCJUV09fUFdSXzE2X0RCTCIsIlRXT19QV1JfMjRfREJMIiwiVFdPX1BXUl8yNCIsIk9ORSIsIlVPTkUiLCJORUdfT05FIiwiTG9uZ1Byb3RvdHlwZSIsInRvSW50IiwidG9OdW1iZXIiLCJ0b1N0cmluZyIsImlzWmVybyIsImlzTmVnYXRpdmUiLCJlcSIsInJhZGl4TG9uZyIsImRpdiIsInJlbTEiLCJzdWIiLCJyZW0iLCJyZW1EaXYiLCJpbnR2YWwiLCJkaWdpdHMiLCJnZXRIaWdoQml0cyIsImdldEhpZ2hCaXRzVW5zaWduZWQiLCJnZXRMb3dCaXRzIiwiZ2V0TG93Qml0c1Vuc2lnbmVkIiwiZ2V0TnVtQml0c0FicyIsImJpdCIsImlzU2FmZUludGVnZXIiLCJ0b3AxMUJpdHMiLCJlcXoiLCJpc1Bvc2l0aXZlIiwiaXNPZGQiLCJpc0V2ZW4iLCJlcXVhbHMiLCJvdGhlciIsIm5vdEVxdWFscyIsIm5lcSIsIm5lIiwibGVzc1RoYW4iLCJjb21wIiwibHQiLCJsZXNzVGhhbk9yRXF1YWwiLCJsdGUiLCJsZSIsImdyZWF0ZXJUaGFuIiwiZ3QiLCJncmVhdGVyVGhhbk9yRXF1YWwiLCJndGUiLCJnZSIsImNvbXBhcmUiLCJ0aGlzTmVnIiwib3RoZXJOZWciLCJuZWdhdGUiLCJub3QiLCJhZGRlbmQiLCJhNDgiLCJhMzIiLCJhMTYiLCJhMDAiLCJiNDgiLCJiMzIiLCJiMTYiLCJiMDAiLCJjNDgiLCJjMzIiLCJjMTYiLCJjMDAiLCJzdWJ0cmFjdCIsInN1YnRyYWhlbmQiLCJtdWx0aXBseSIsIm11bHRpcGxpZXIiLCJkaXZpZGUiLCJkaXZpc29yIiwiYXBwcm94IiwicmVzIiwiaGFsZlRoaXMiLCJzaHIiLCJzaGwiLCJ0b1Vuc2lnbmVkIiwic2hydSIsIm1heCIsImZsb29yIiwibG9nMiIsImNlaWwiLCJsb2ciLCJMTjIiLCJkZWx0YSIsImFwcHJveFJlcyIsImFwcHJveFJlbSIsIm1vZHVsbyIsIm1vZCIsImNvdW50TGVhZGluZ1plcm9zIiwiY2x6IiwiY291bnRUcmFpbGluZ1plcm9zIiwiY3R6IiwiYW5kIiwib3IiLCJ4b3IiLCJzaGlmdExlZnQiLCJudW1CaXRzIiwic2hpZnRSaWdodCIsInNoaWZ0UmlnaHRVbnNpZ25lZCIsInNocl91Iiwicm90YXRlTGVmdCIsImIiLCJyb3RsIiwicm90YXRlUmlnaHQiLCJyb3RyIiwidG9TaWduZWQiLCJ0b0J5dGVzIiwidG9CeXRlc0xFIiwidG9CeXRlc0JFIiwiaGkiLCJsbyIsImZyb21CeXRlcyIsImJ5dGVzIiwiZnJvbUJ5dGVzTEUiLCJmcm9tQnl0ZXNCRSIsIkJpZ0ludCIsImZyb21CaWdJbnQiLCJOdW1iZXIiLCJhc0ludE4iLCJmcm9tVmFsdWVXaXRoQmlnSW50IiwidG9CaWdJbnQiLCJsb3dCaWdJbnQiLCJoaWdoQmlnSW50IiwiX2RlZmF1bHQiLCJkZWZpbmUiLCJhbWQiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/long/umd/index.js\n");

/***/ })

};
;